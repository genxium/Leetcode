The "SegmentTree" solution here might look a bit unfamiliar to some, please read [this note](https://www.yinxiang.com/everhub/note/b904af18-03fd-4dbc-a3d2-67a0daa1518e) and checkout [p307_Range_Sum_Query_Mutable](https://github.com/genxium/Leetcode/tree/master/p307_Range_Sum_Query_Mutable) beforehand to get more comfortable about it.

**Why don't we need the `lazy-push-down`(e.g. [`pushDownAtMostOneLevel` method for p307_Range_Sum_Query_Mutable]((https://github.com/genxium/Leetcode/blob/b1d3f2b2a54214ce1daea3898fa4cd5c4cd9085e/p307_Range_Sum_Query_Mutable/submission_segtree.cpp#L66))) of a regular Lazy SegmentTree when applying `RangeAdd` to maintain `Node.activeBottomLengthSum` in this problem?** Because in the order of `RangeAdd(5, 19, +1)` doesn't necessarily contribute `3` (i.e. 19-16=3) to `Node(16, 32).` -- just `at most 3`, but the contribution could be any value among `{0, 1, 2, 3}` depending on the state of coverage within `Node(16, 32)`. It could've been more difficult than the "regular sum-over-interval  `Node.pSum` from all overlapping `RangeAdd` operations" in the note, if not managed by the `(y & bottom/top)-sorting preprocess`, which made it **actually easier than the regular problem in note, i.e. no `lazy-push-down` required for maintaining `full cover laziness`**.

See [p391_Perfect_Rectangle](https://github.com/genxium/Leetcode/tree/master/p391_Perfect_Rectangle) for a more compact version that maintains the same `fullCoverAccDiff` and `activeBottomLengthSum` with a single `RangeAdd (no lazy-push-down)` method.
