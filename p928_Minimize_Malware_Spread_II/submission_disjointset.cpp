bool debug = false;
int const MAXN = 300;
int const INVALID = -1;

typedef vector<int> VI;

int djsFindRoot(int u, VI& djsParent, VI& djsSize) {
    int cur = u;
    int p = djsParent[cur];
    if (INVALID == p) {
        djsParent[u] = u; // lazy init
        djsSize[u] = 1;
        return u;
    }
    while (p != cur) {
        cur = p;
        p = djsFindRoot(cur, djsParent, djsSize); // lazy path compression
    }
    djsParent[u] = p;
    return p;
}

int djsUnite(int u, int v, VI& djsParent, VI& djsSize) {
    int uRoot = djsFindRoot(u, djsParent, djsSize);
    int vRoot = djsFindRoot(v, djsParent, djsSize);
    if (uRoot == vRoot) return uRoot;
    
    // [WARNING] Always attach to smaller root!
    if (uRoot < vRoot) {
        djsSize[uRoot] += djsSize[vRoot];
        return djsParent[vRoot] = uRoot;
    } else {
        djsSize[vRoot] += djsSize[uRoot];
        return djsParent[uRoot] = vRoot;
    }
}

/*
test cases
[[1,1,0],[1,1,0],[0,0,1]]
[0,1]
[[1,1,0],[1,1,1],[0,1,1]]
[0,1]
[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]
[0,1]
[[1,0,0,0,0,0,0,0,0],[0,1,0,0,0,0,0,0,0],[0,0,1,0,1,0,1,0,0],[0,0,0,1,0,0,0,0,0],[0,0,1,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,1,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1]]
[6,0,4]
[[1,0,0,0,0,0,0,0,1],[0,1,0,1,0,0,0,0,0],[0,0,1,1,0,1,0,0,0],[0,1,1,1,1,0,1,0,0],[0,0,0,1,1,1,0,0,0],[0,0,1,0,1,1,0,0,0],[0,0,0,1,0,0,1,1,0],[0,0,0,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1]]
[3,7]
0 ----- 8
        |
    6 - 7*
    |
1 --3*-- 4 
   /    /
  /    / 
 2 -- 5
*/
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        /*
        This problem looks like a indirectional bridge problem at the first sight, but is actually NOT, because breaking 1 node can isolate many neighbours simultaneously, even if there were no bridge.

        The key idea is to find for any "non-malware v", how many "malware u" can reach it by a "non-malware-path".
        */
        int n = graph.size();
        VI isMalware(n, false);
        
        for (auto u : initial) {
            isMalware[u] = true;
        }
        
        // Init non-malware-paths
        VI djsParentNonmalwareOnly(n, INVALID), djsSizeNonmalwareOnly(n, 0);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (0 == graph[i][j]) continue;
                if (isMalware[i] || isMalware[j]) continue;
                djsUnite(i, j, djsParentNonmalwareOnly, djsSizeNonmalwareOnly);
            }
        }
        
        // Check which "malware u" can reach most "non-malware v"s by "non-malware-path".
        unordered_map<int, VI> reachableFrom;
        for (auto u : initial) {
            VI djsParent(djsParentNonmalwareOnly), djsSize(djsSizeNonmalwareOnly);
            for (int v = 0; v < n; ++v) {
                if (0 == graph[u][v]) continue;
                if (isMalware[v]) continue;
                djsUnite(u, v, djsParent, djsSize);
            }
            
            for (int v = 0; v < n; ++v) {
                if (isMalware[v]) continue;
                int uRoot = djsFindRoot(u, djsParent, djsSize);
                int vRoot = djsFindRoot(v, djsParent, djsSize);
                
                if (uRoot == vRoot) {
                    reachableFrom[v].push_back(u);
                }
            }
        }
        
        // Check which "malware u" has most "uniquely reachable non-malware v"s.
        unordered_map<int, int> uniquelyReachableCnt;
        for (int v = 0; v < n; ++v) {
            if (isMalware[v]) continue;
            if (1 == reachableFrom[v].size()) {
                ++uniquelyReachableCnt[reachableFrom[v][0]];
            }
        }
        
        int ansGraphId = INVALID, ansReduction = 0;
        for (auto u : initial) {
            if (debug) printf("uniquelyReachableCnt[u:%d] is %d\n", u, uniquelyReachableCnt[u]);
            if (INVALID == ansGraphId) {
                // lazy init
                ansGraphId = u;
                ansReduction = uniquelyReachableCnt[u];
            }
            
            if (uniquelyReachableCnt[u] > ansReduction || (uniquelyReachableCnt[u] == ansReduction && u < ansGraphId)) {
                ansGraphId = u;
                ansReduction = uniquelyReachableCnt[u];
            }
        }
        
        return ansGraphId;
    }
};
